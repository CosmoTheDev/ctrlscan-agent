package agent

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	aiPkg "github.com/CosmoTheDev/ctrlscan-agent/internal/ai"
	"github.com/CosmoTheDev/ctrlscan-agent/internal/config"
	"github.com/CosmoTheDev/ctrlscan-agent/internal/database"
	"github.com/CosmoTheDev/ctrlscan-agent/internal/repository"
	"github.com/CosmoTheDev/ctrlscan-agent/models"
)

// PRAgent reads approved fixes from fix_queue, applies them, and creates PRs.
type PRAgent struct {
	cfg *config.Config
	db  database.DB
	ai  aiPkg.AIProvider
}

// NewPRAgent creates a PRAgent.
func NewPRAgent(cfg *config.Config, db database.DB, ai aiPkg.AIProvider) *PRAgent {
	return &PRAgent{cfg: cfg, db: db, ai: ai}
}

// ProcessApprovedFixes polls fix_queue for approved fixes and creates PRs.
// Call this from the orchestrator or a separate goroutine.
func (a *PRAgent) ProcessApprovedFixes(ctx context.Context) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			a.drainApprovedFixes(ctx)
		case <-ctx.Done():
			return
		}
	}
}

func (a *PRAgent) drainApprovedFixes(ctx context.Context) {
	type fixRow struct {
		ID         int64   `db:"id"`
		ScanJobID  int64   `db:"scan_job_id"`
		FindingType string `db:"finding_type"`
		FindingID   int64  `db:"finding_id"`
		Patch      string  `db:"patch"`
		PRTitle    string  `db:"pr_title"`
		PRBody     string  `db:"pr_body"`
		Status     string  `db:"status"`
		PRNumber   int     `db:"pr_number"`
		PRURL      string  `db:"pr_url"`
	}
	var rows []fixRow
	if err := a.db.Select(ctx, &rows,
		`SELECT id, scan_job_id, finding_type, finding_id, patch, pr_title, pr_body, status, pr_number, pr_url
		   FROM fix_queue
		  WHERE status = 'approved'
		  ORDER BY id ASC
		  LIMIT 20`); err != nil {
		slog.Warn("Failed to load approved fixes", "error", err)
		return
	}

	for _, row := range rows {
		if ctx.Err() != nil {
			return
		}
		fix := models.FixQueue{
			ID:          row.ID,
			ScanJobID:   row.ScanJobID,
			FindingType: row.FindingType,
			FindingID:   row.FindingID,
			Patch:       row.Patch,
			PRTitle:     row.PRTitle,
			PRBody:      row.PRBody,
			Status:      row.Status,
			PRNumber:    row.PRNumber,
			PRURL:       row.PRURL,
		}
		if err := a.createPR(ctx, fix); err != nil {
			if isRetryablePRCreationError(err) {
				slog.Warn("PR creation delayed; will retry",
					"fix_id", fix.ID,
					"error", err,
				)
				// Keep status=approved so the PR worker can retry on the next pass.
				continue
			}
			slog.Error("PR creation failed", "fix_id", fix.ID, "error", err)
			_ = a.db.Exec(ctx,
				`UPDATE fix_queue SET status = 'pr_failed' WHERE id = ?`, fix.ID)
		}
	}
}

func (a *PRAgent) createPR(ctx context.Context, fix models.FixQueue) error {
	slog.Info("Creating PR for fix", "fix_id", fix.ID)

	// Load the scan job to get repo details.
	var job struct {
		ID       int64  `db:"id"`
		Provider string `db:"provider"`
		Owner    string `db:"owner"`
		Repo     string `db:"repo"`
		Branch   string `db:"branch"`
	}
	if err := a.db.Get(ctx, &job, `
		SELECT id, provider, owner, repo, branch
		FROM scan_jobs
		WHERE id = ?`, fix.ScanJobID); err != nil {
		return fmt.Errorf("loading scan job: %w", err)
	}

	// Build the repository provider.
	provider, err := repository.New(job.Provider, a.cfg)
	if err != nil {
		return fmt.Errorf("building provider: %w", err)
	}

	// Prefer fork-based PRs, but fall back to direct-branch PRs when forking
	// fails and the token has write access to the upstream repository.
	var (
		cloneURL string
		headRef  string
		forkMode bool
	)
	fork, err := provider.ForkRepo(ctx, job.Owner, job.Repo)
	if err != nil {
		slog.Warn("Fork failed; attempting direct PR fallback",
			"owner", job.Owner,
			"repo", job.Repo,
			"error", err,
		)
		upstream, getErr := provider.GetRepo(ctx, job.Owner, job.Repo)
		if getErr != nil {
			return fmt.Errorf("forking %s/%s: %w (direct fallback get repo failed: %v)", job.Owner, job.Repo, err, getErr)
		}
		cloneURL = upstream.CloneURL
		forkMode = false
	} else {
		cloneURL = fork.CloneURL
		forkMode = true
	}

	// Clone target remote (fork preferred, upstream on fallback) to a temp directory.
	cm := repository.NewCloneManager(a.cfg.Tools.BinDir)
	cloneResult, err := cm.Clone(ctx, cloneURL, provider.AuthToken(), job.Branch)
	if err != nil {
		if forkMode {
			return fmt.Errorf("cloning fork: %w", err)
		}
		return fmt.Errorf("cloning upstream for direct PR fallback: %w", err)
	}
	defer cm.Cleanup(cloneResult)

	// Create a fix branch.
	branchName := fmt.Sprintf("ctrlscan/fix-%d-%d", fix.ScanJobID, fix.ID)
	if err := gitCreateBranch(cloneResult.LocalPath, branchName); err != nil {
		return fmt.Errorf("creating branch: %w", err)
	}

	// Apply the patch.
	if err := applyPatch(cloneResult.LocalPath, fix.Patch); err != nil {
		return fmt.Errorf("applying patch: %w", err)
	}

	// Commit the change.
	commitMsg := fix.PRTitle + "\n\nGenerated by ctrlscan."
	if err := gitCommit(cloneResult.LocalPath, commitMsg); err != nil {
		return fmt.Errorf("committing fix: %w", err)
	}

	// Push branch.
	if err := gitPush(cloneResult.LocalPath, branchName, provider.AuthToken(), cloneURL); err != nil {
		if forkMode {
			return fmt.Errorf("pushing fork branch: %w", err)
		}
		return fmt.Errorf("pushing direct branch to upstream: %w", err)
	}
	if forkMode {
		// GitHub/GitLab generally require the fork owner's branch namespace.
		// If owner is empty for any reason, fall back to bare branch.
		if strings.TrimSpace(fork.Owner) != "" {
			headRef = fmt.Sprintf("%s:%s", fork.Owner, branchName)
		}
	}
	if headRef == "" {
		headRef = branchName
	}

	// Generate PR description.
	prDesc := &aiPkg.PRDescription{
		Title: fix.PRTitle,
		Body:  fix.PRBody,
	}

	// Create the pull request against the original (not fork).
	pr, err := provider.CreatePR(ctx, repository.CreatePROptions{
		Owner:      job.Owner,
		Repo:       job.Repo,
		Title:      prDesc.Title,
		Body:       prDesc.Body,
		HeadBranch: headRef,
		BaseBranch: job.Branch,
		Draft:      a.cfg.Agent.Mode == "triage", // draft in triage mode
	})
	if err != nil {
		return fmt.Errorf("creating PR: %w", err)
	}

	slog.Info("PR created", "url", pr.URL, "number", pr.Number)

	// Update fix_queue status.
	now := time.Now().UTC().Format(time.RFC3339)
	if err := a.db.Exec(ctx,
		`UPDATE fix_queue SET status = 'pr_open', pr_number = ?, pr_url = ?, approved_at = ? WHERE id = ?`,
		pr.Number, pr.URL, now, fix.ID,
	); err != nil {
		slog.Warn("Failed to update fix_queue", "error", err)
	}

	// In semi/auto mode: open browser.
	if a.cfg.Agent.Mode == "semi" || a.cfg.Agent.Mode == "auto" {
		openBrowser(pr.URL)
	}

	return nil
}

// --- git helpers ---

func gitCreateBranch(repoPath, branch string) error {
	return runGit(repoPath, "checkout", "-b", branch)
}

func gitCommit(repoPath, message string) error {
	if err := runGit(repoPath, "add", "-A"); err != nil {
		return err
	}
	return runGit(repoPath, "commit", "-m", message,
		"--author", "ctrlscan <ctrlscan@users.noreply.github.com>")
}

func gitPush(repoPath, branch, token, remoteURL string) error {
	// Inject token into the remote URL.
	authedURL := injectToken(remoteURL, token)
	if err := runGit(repoPath, "remote", "set-url", "origin", authedURL); err != nil {
		return err
	}
	return runGit(repoPath, "push", "-u", "origin", branch)
}

func applyPatch(repoPath, patch string) error {
	if strings.TrimSpace(patch) == "" {
		return fmt.Errorf("empty patch")
	}
	patchFile := filepath.Join(repoPath, ".ctrlscan.patch")
	if err := os.WriteFile(patchFile, []byte(patch), 0o644); err != nil {
		return err
	}
	defer os.Remove(patchFile)
	return runGit(repoPath, "apply", patchFile)
}

func runGit(dir string, args ...string) error {
	cmd := exec.Command("git", args...)
	cmd.Dir = dir
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("git %s: %w\n%s", strings.Join(args, " "), err, string(out))
	}
	return nil
}

func injectToken(repoURL, token string) string {
	if token == "" || !strings.Contains(repoURL, "://") {
		return repoURL
	}
	parts := strings.SplitN(repoURL, "://", 2)
	return parts[0] + "://ctrlscan:" + token + "@" + parts[1]
}

func isRetryablePRCreationError(err error) bool {
	if err == nil {
		return false
	}
	msg := strings.ToLower(err.Error())
	switch {
	case strings.Contains(msg, "job scheduled on github side"),
		strings.Contains(msg, "try again later"),
		strings.Contains(msg, "rate limit"),
		strings.Contains(msg, "timeout"),
		strings.Contains(msg, "temporar"),
		strings.Contains(msg, "5xx"):
		return true
	default:
		return false
	}
}
