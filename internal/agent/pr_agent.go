package agent

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	aiPkg "github.com/CosmoTheDev/ctrlscan-agent/internal/ai"
	"github.com/CosmoTheDev/ctrlscan-agent/internal/config"
	"github.com/CosmoTheDev/ctrlscan-agent/internal/database"
	"github.com/CosmoTheDev/ctrlscan-agent/internal/repository"
	"github.com/CosmoTheDev/ctrlscan-agent/models"
)

// PRAgent reads approved fixes from fix_queue, applies them, and creates PRs.
type PRAgent struct {
	cfg *config.Config
	db  database.DB
	ai  aiPkg.AIProvider
}

// NewPRAgent creates a PRAgent.
func NewPRAgent(cfg *config.Config, db database.DB, ai aiPkg.AIProvider) *PRAgent {
	return &PRAgent{cfg: cfg, db: db, ai: ai}
}

// ProcessApprovedFixes polls fix_queue for approved fixes and creates PRs.
// Call this from the orchestrator or a separate goroutine.
func (a *PRAgent) ProcessApprovedFixes(ctx context.Context) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			a.drainApprovedFixes(ctx)
		case <-ctx.Done():
			return
		}
	}
}

func (a *PRAgent) drainApprovedFixes(ctx context.Context) {
	var fixes []models.FixQueue
	if err := a.db.Select(ctx, &fixes,
		`SELECT * FROM fix_queue WHERE status = 'approved' LIMIT 20`); err != nil {
		slog.Warn("Failed to load approved fixes", "error", err)
		return
	}

	for _, fix := range fixes {
		if ctx.Err() != nil {
			return
		}
		if err := a.createPR(ctx, fix); err != nil {
			slog.Error("PR creation failed", "fix_id", fix.ID, "error", err)
			_ = a.db.Exec(ctx,
				`UPDATE fix_queue SET status = 'pr_failed' WHERE id = ?`, fix.ID)
		}
	}
}

func (a *PRAgent) createPR(ctx context.Context, fix models.FixQueue) error {
	slog.Info("Creating PR for fix", "fix_id", fix.ID)

	// Load the scan job to get repo details.
	var job models.ScanJob
	if err := a.db.Get(ctx, &job, `SELECT * FROM scan_jobs WHERE id = ?`, fix.ScanJobID); err != nil {
		return fmt.Errorf("loading scan job: %w", err)
	}

	// Build the repository provider.
	provider, err := repository.New(job.Provider, a.cfg)
	if err != nil {
		return fmt.Errorf("building provider: %w", err)
	}

	// Fork the upstream repo.
	fork, err := provider.ForkRepo(ctx, job.Owner, job.Repo)
	if err != nil {
		return fmt.Errorf("forking %s/%s: %w", job.Owner, job.Repo, err)
	}

	// Clone the fork to a temp directory.
	cm := repository.NewCloneManager(a.cfg.Tools.BinDir)
	cloneResult, err := cm.Clone(ctx, fork.CloneURL, provider.AuthToken(), job.Branch)
	if err != nil {
		return fmt.Errorf("cloning fork: %w", err)
	}
	defer cm.Cleanup(cloneResult)

	// Create a fix branch.
	branchName := fmt.Sprintf("ctrlscan/fix-%d-%d", fix.ScanJobID, fix.ID)
	if err := gitCreateBranch(cloneResult.LocalPath, branchName); err != nil {
		return fmt.Errorf("creating branch: %w", err)
	}

	// Apply the patch.
	if err := applyPatch(cloneResult.LocalPath, fix.Patch); err != nil {
		return fmt.Errorf("applying patch: %w", err)
	}

	// Commit the change.
	commitMsg := fix.PRTitle + "\n\nGenerated by ctrlscan."
	if err := gitCommit(cloneResult.LocalPath, commitMsg); err != nil {
		return fmt.Errorf("committing fix: %w", err)
	}

	// Push branch.
	if err := gitPush(cloneResult.LocalPath, branchName, provider.AuthToken(), fork.CloneURL); err != nil {
		return fmt.Errorf("pushing branch: %w", err)
	}

	// Generate PR description.
	prDesc := &aiPkg.PRDescription{
		Title: fix.PRTitle,
		Body:  fix.PRBody,
	}

	// Create the pull request against the original (not fork).
	pr, err := provider.CreatePR(ctx, repository.CreatePROptions{
		Owner:      job.Owner,
		Repo:       job.Repo,
		Title:      prDesc.Title,
		Body:       prDesc.Body,
		HeadBranch: branchName,
		BaseBranch: job.Branch,
		Draft:      a.cfg.Agent.Mode == "triage", // draft in triage mode
	})
	if err != nil {
		return fmt.Errorf("creating PR: %w", err)
	}

	slog.Info("PR created", "url", pr.URL, "number", pr.Number)

	// Update fix_queue status.
	now := time.Now().UTC().Format(time.RFC3339)
	if err := a.db.Exec(ctx,
		`UPDATE fix_queue SET status = 'pr_open', pr_number = ?, pr_url = ?, approved_at = ? WHERE id = ?`,
		pr.Number, pr.URL, now, fix.ID,
	); err != nil {
		slog.Warn("Failed to update fix_queue", "error", err)
	}

	// In semi/auto mode: open browser.
	if a.cfg.Agent.Mode == "semi" || a.cfg.Agent.Mode == "auto" {
		openBrowser(pr.URL)
	}

	return nil
}

// --- git helpers ---

func gitCreateBranch(repoPath, branch string) error {
	return runGit(repoPath, "checkout", "-b", branch)
}

func gitCommit(repoPath, message string) error {
	if err := runGit(repoPath, "add", "-A"); err != nil {
		return err
	}
	return runGit(repoPath, "commit", "-m", message,
		"--author", "ctrlscan <ctrlscan@users.noreply.github.com>")
}

func gitPush(repoPath, branch, token, remoteURL string) error {
	// Inject token into the remote URL.
	authedURL := injectToken(remoteURL, token)
	if err := runGit(repoPath, "remote", "set-url", "origin", authedURL); err != nil {
		return err
	}
	return runGit(repoPath, "push", "-u", "origin", branch)
}

func applyPatch(repoPath, patch string) error {
	if strings.TrimSpace(patch) == "" {
		return fmt.Errorf("empty patch")
	}
	patchFile := filepath.Join(repoPath, ".ctrlscan.patch")
	if err := os.WriteFile(patchFile, []byte(patch), 0o644); err != nil {
		return err
	}
	defer os.Remove(patchFile)
	return runGit(repoPath, "apply", patchFile)
}

func runGit(dir string, args ...string) error {
	cmd := exec.Command("git", args...)
	cmd.Dir = dir
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("git %s: %w\n%s", strings.Join(args, " "), err, string(out))
	}
	return nil
}

func injectToken(repoURL, token string) string {
	if token == "" || !strings.Contains(repoURL, "://") {
		return repoURL
	}
	parts := strings.SplitN(repoURL, "://", 2)
	return parts[0] + "://ctrlscan:" + token + "@" + parts[1]
}
